// Code generated by enumgen; DO NOT EDIT
package {{ .Package }}
import (
	"encoding/json"
	"fmt"
)
type {{ .Type }} string
{{ $sValues := .StylizedValues }}
const ( {{range $index,$val := .Values }}
    {{ $.Type }}{{ ToPascalCasing $val }}    {{ $.Type }} = "{{index $sValues $index}}"{{end}}
)

var {{ .AllValuesVarName }} = []{{ .Type }}{ {{range $val := .Values}}
	{{ $.Type }}{{ ToPascalCasing $val }},{{end}}
}
type {{ .TypeLower }}Obj struct {}

var {{.TypeLower}}Map = map[{{ .Type }}]{{.TypeLower}}Obj{ {{range $val := .Values}}
        {{ $.Type }}{{ ToPascalCasing $val }}: {},{{end}}
}

func ({{ .FirstLetter }} {{ .Type }}) MarshalJSON() ([]byte, error) {
	return json.Marshal({{ .FirstLetter }}.String())
}

func ({{ .FirstLetter }} *{{ .Type }}) UnmarshalJSON(bytes []byte) error {
	var name string
	err := json.Unmarshal(bytes, &name)
	if err != nil {
		return err
	}
	val, err := {{ .Type }}FromString(name)
	if err != nil {
		return err
	}
	* {{ .FirstLetter }} = val

	return nil
}
func {{ .Type }}FromString(v string) ({{ .Type }}, error) {
	for _, known := range {{ .AllValuesVarName }} {
		if v == known.String() {
			return known, nil
		}
	}
	return "", fmt.Errorf("unable to find {{ .Type }} with value %s", v)
}

func ({{ .FirstLetter }} {{ .Type }}) String() string{
    return string({{ .FirstLetter }})
}

func ({{ .FirstLetter }} {{ .Type }}) IsValid() bool {
    _, ok := {{.TypeLower}}Map[{{ .FirstLetter }}]
    return ok
}

func ({{ .FirstLetter }} {{ .Type }}) IsGeneratedGoEnum() bool {
    return true
}